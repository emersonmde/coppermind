//! Coppermind custom evaluation dataset loader.
//!
//! Loads the custom dataset generated by scripts/generate-dataset.sh.
//! This dataset is specifically designed to test hybrid search with
//! a mix of query types:
//! - Short keyword queries (2-3 words)
//! - Partial phrase queries
//! - Natural language questions

use super::EvalDataset;
use serde::Deserialize;
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

#[derive(Debug, Deserialize)]
struct CorpusEntry {
    _id: String,
    title: String,
    text: String,
}

#[derive(Debug, Deserialize)]
struct QueryEntry {
    _id: String,
    text: String,
}

/// Load the custom Coppermind evaluation dataset.
///
/// # Arguments
/// * `data_dir` - Path to the eval data directory (contains coppermind-eval/)
pub fn load_coppermind_dataset(data_dir: &Path) -> Result<EvalDataset, String> {
    let dataset_dir = data_dir.join("coppermind-eval");

    let corpus_path = dataset_dir.join("corpus.jsonl");
    let queries_path = dataset_dir.join("queries.jsonl");
    let qrels_path = dataset_dir.join("qrels.tsv");

    if !corpus_path.exists() {
        return Err(format!(
            "Coppermind eval dataset not found at {}\n\n\
            Generate it with:\n  \
            cd crates/coppermind-eval && ./scripts/generate-dataset.sh",
            corpus_path.display()
        ));
    }

    // Load corpus
    eprintln!("Loading Coppermind corpus...");
    let documents = load_corpus(&corpus_path)?;
    eprintln!("  {} documents loaded", documents.len());

    // Load queries
    eprintln!("Loading Coppermind queries...");
    let queries = load_queries(&queries_path)?;
    eprintln!("  {} queries loaded", queries.len());

    // Load qrels
    eprintln!("Loading Coppermind qrels...");
    let qrels = load_qrels(&qrels_path)?;
    let num_qrels: usize = qrels.values().map(|d| d.len()).sum();
    eprintln!("  {} relevance judgments loaded", num_qrels);

    Ok(EvalDataset {
        name: "Coppermind Custom".to_string(),
        documents,
        queries,
        qrels,
    })
}

fn load_corpus(path: &Path) -> Result<Vec<(String, String, String)>, String> {
    let file = File::open(path).map_err(|e| format!("Failed to open corpus: {}", e))?;
    let reader = BufReader::new(file);

    let mut documents = Vec::new();

    for (i, line) in reader.lines().enumerate() {
        let line = line.map_err(|e| format!("Read error at line {}: {}", i, e))?;
        let entry: CorpusEntry =
            serde_json::from_str(&line).map_err(|e| format!("JSON error at line {}: {}", i, e))?;
        documents.push((entry._id, entry.title, entry.text));
    }

    Ok(documents)
}

fn load_queries(path: &Path) -> Result<Vec<(String, String)>, String> {
    let file = File::open(path).map_err(|e| format!("Failed to open queries: {}", e))?;
    let reader = BufReader::new(file);

    let mut queries = Vec::new();

    for (i, line) in reader.lines().enumerate() {
        let line = line.map_err(|e| format!("Read error at line {}: {}", i, e))?;
        let entry: QueryEntry =
            serde_json::from_str(&line).map_err(|e| format!("JSON error at line {}: {}", i, e))?;
        queries.push((entry._id, entry.text));
    }

    Ok(queries)
}

fn load_qrels(path: &Path) -> Result<HashMap<String, HashMap<String, u8>>, String> {
    let file = File::open(path).map_err(|e| format!("Failed to open qrels: {}", e))?;
    let reader = BufReader::new(file);

    let mut qrels: HashMap<String, HashMap<String, u8>> = HashMap::new();

    for (i, line) in reader.lines().enumerate() {
        let line = line.map_err(|e| format!("Read error at line {}: {}", i, e))?;

        // Skip header
        if i == 0 && line.starts_with("query-id") {
            continue;
        }

        let parts: Vec<&str> = line.split('\t').collect();
        if parts.len() >= 3 {
            let query_id = parts[0].to_string();
            let doc_id = parts[1].to_string();
            let relevance: u8 = parts[2]
                .parse()
                .map_err(|_| format!("Invalid relevance at line {}", i))?;

            qrels.entry(query_id).or_default().insert(doc_id, relevance);
        }
    }

    Ok(qrels)
}
